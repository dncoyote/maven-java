# **Framework, Libraries and Technologies: Interview Question Bank**

### **HTTP Requests**

- HTTP is the protocol used by web browsers and servers to communicate and exchange information.
- An HTTP request is a message sent by a client, typically a web browser or an application, to request data from a server.
- HTTP request typically consists of the following components:

  - HTTP Method: This indicates the type of request being made, such as GET, POST, PUT, DELETE, etc. Each HTTP method has a specific purpose, such as retrieving data (GET), submitting data (POST), updating data (PUT), or deleting data (DELETE).
  - URL (Uniform Resource Locator): This specifies the web address of the resource being requested. It includes the protocol (e.g., http:// or https://), the domain name (e.g., www.example.com), and the path to the resource (e.g., /images/pic.jpg).
  - Headers: These are key-value pairs that provide additional information about the request, such as the type of data being sent, the language preference, caching settings, and more. Headers are used to convey meta-information about the request to the server.
  - Body (optional): This is the data, such as form data or JSON, that is sent as part of the request. It is typically used in POST, PUT, and DELETE requests to send data to the server.

- Once the HTTP request is sent to the server, the server processes the request and generates an HTTP response, which is sent back to the client with the requested data. The response typically contains a response status code indicating the outcome of the request (e.g., 200 OK, 404 Not Found, etc.), headers with additional information, and optionally, a response body with the requested data.

---

### **REST API**

- A REST API (Representational State Transfer Application Programming Interface) is a type of web API that uses HTTP requests to perform operations on data.
---

### **REST API Authentication**

---

### **JWT**
 - JSON Web Token is a standard that defines a compact and self-contained way to transmit information between parties as a JSON object. JWTs are commonly used for authentication and authorization in web applications and APIs.
 - Authentication and authorization is performed by sending them in the HTTP Authorization header of a request to an API. The JWT is then verified on the server-side to ensure that it is valid and that the user has the necessary permissions to access the requested resource.
 - A JWT is composed of three parts: 
   - Header: The header contains metadata about the JWT, such as the type of token and the hashing algorithm used to generate the signature. 
   - Payload: The payload contains claims, which are statements about an entity (typically the user) and additional metadata. Claims can be used to provide information such as the user's identity, role, or permissions.
   - Signature: The signature is used to verify that the message has not been tampered with and that the sender is who they claim to be.
---

### **Bearer Token**
- A bearer token is a type of access token used in OAuth 2.0 authentication. It is a security token that is used to grant access to a protected resource, such as a REST API.
- A bearer token is essentially a string of characters that is generated by the authorization server after the user has provided their credentials. The token is then sent to the client (such as a web or mobile application) and included in the header of each subsequent API request to access the protected resource.
- Bearer tokens are typically short-lived and can be invalidated by the authorization server if they are compromised or stolen.
---

### **Spring Boot Actuator**
 - Spring Boot Actuator is a sub-project of Spring Boot that provides endpoints and tools for monitoring and managing a Spring Boot application. Spring Boot Actuator provides several features, including:
   - Health checks
   - Metrics
   - Auditing
   - Environment and configuration
   - Endpoints
  
---

### **ControllerAdvice**
 - `@ControllerAdvice` is an annotation used to define global exception handlers that are applied to all controllers in an application.
 - When an exception occurs during the execution of a controller method, Spring Boot looks for an appropriate exception handler to handle the exception. If no specific exception handler is found, Spring Boot looks for a global exception handler defined using the `@ControllerAdvice` annotation.
 - This can be useful for handling common exceptions such as NullPointerException, IllegalArgumentException, or IllegalStateException.  
    ```
    @ControllerAdvice
    public class GlobalExceptionHandler {

      @ExceptionHandler(value = {NullPointerException.class, IllegalArgumentException.class})
      public ResponseEntity<Object> handleException(Exception ex) {
          return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
      }
    }
    ```
---

### **Spring Stereotype annotation**
---

### **IAM**
---

### **Keycloak**

---

### **JPA**

---

### **Hibernate**

---

### **Hibernate Interfaces**

---

### **Hibernate Caches**
 - Hibernate provides several caching mechanisms to improve the performance of database operations. These caching mechanisms help reduce the number of trips to the database and minimize the time required to fetch or store data
    - First-level Cache (Session Cache): Also known as the session cache, it is the default and most basic cache provided by Hibernate. It operates at the session level and stores entities and their associated data within the context of a single Hibernate session. It helps in reducing database round trips by caching and reusing the retrieved entities during the session.

    - Second-level Cache: The second-level cache is a shared cache that operates at the session factory level. It caches objects across multiple sessions, allowing data to be shared among different sessions and reducing the need for repeated database queries. Hibernate supports various second-level cache providers, such as Ehcache, Infinispan, Hazelcast, and more.

    - Query Cache: The query cache is used to cache the results of queries. When enabled, the query results are stored in the cache based on the query parameters. Subsequent executions of the same query with the same parameters can be served from the cache without hitting the database.

    - Collection Cache: Hibernate also provides a cache for collections, such as one-to-many or many-to-many associations. It allows caching of the associated collection elements, improving the performance of fetching related entities.
---

### **Hibernate Locks**

---

### **Hibernate v/s JPA**

---

### **JPA Repository**

---

### **Spring Boot**

---

### **Beans in Spring Boot**
 - In Spring Boot, beans are created using a process called "dependency injection". Dependency injection is a design pattern in which objects are passed their dependencies instead of creating them themselves. This pattern is implemented by the Spring framework, and it allows for loosely-coupled and easily testable code.
 - When a Spring Boot application starts up, the Spring framework scans the project for classes that are annotated with @Component, @Service, @Controller, @Repository, or @Configuration. These annotations indicate that a class should be treated as a bean, and Spring creates an instance of the class and registers it in its container.
---

### **Controller v/s RestController**
| Controller  | RestController |
|----------|----------|
| `@Controller` annotation is used to define a controller class in Spring MVC. Controllers are primarily used for handling traditional web-based applications where the response can be in various forms, such as HTML pages, JSON/XML responses, file downloads, etc.  |`@RestController` annotation is a specialized version of the Controller annotation that combines @Controller and @ResponseBody. It is used to define controllers specifically for building RESTful APIs where the response is typically in JSON/XML format. The @ResponseBody annotation is applied to the methods within a RestController to indicate that the return value should be serialized directly into the response body. |
---

### **Profile in Spring Boot**
- Profiles are a feature that allows you to configure and customize your application based on different environments or deployment scenarios. Profiles provide a way to have multiple sets of configuration properties and beans within a single codebase, enabling you to switch between different configurations easily.
---

### **Qualifiers in Spring Boot**
 - Qualifiers are used to differentiate between beans of the same type when multiple instances of a bean exist in the application context.
    ```
    @Component
    @Qualifier("fooQualifier")
    public class FooBean implements MyInterface {
        // ...
    }

    @Component
    @Qualifier("barQualifier")
    public class BarBean implements MyInterface {
        // ...
    }
    ------------
    @Service
    public class MyService {

    private final MyInterface myInterface;

    public MyService(@Qualifier("fooQualifier") MyInterface myInterface) {
        this.myInterface = myInterface;
    }
    }

    ```

---

### **@Autowired**

---

### **Microservices**

---

### **API Gateway**

---

### **Load Balancing in API Gateway**

---

### **Service Discovery**

---

### **Eureka Server**

---

### **@FeignClient**

---

### **Transactional**

---

### **Docker**

---

### **Docker file contents**

---

### **Kubernetes**

---

### **Queueing Libraries**

---

### **Apache Kafka**

---

### **Message Queueing**

---

### **Rabbit MQ**

---

### **MQTT/Mosquito**

---

### **Redis**

---

### **hystrix**

---

### **Swagger**

---

### **EC2**

---

### **Amplify**

---

### **DynamoDB**

---

### **Lambda**

---

### **REST**

---

### **HTTP Requests**

---

### **Lazy Loading**

---

### **Eager Loading**

---

### **SOLID principles**

---

### **Design Patterns**

---

### **Categories of Design Patterns**

---
